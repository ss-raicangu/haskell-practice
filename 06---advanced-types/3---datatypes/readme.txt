====================================================================================
 https://en.wikibooks.org/wiki/Yet_Another_Haskell_Tutorial/Type_advanced#Datatypes
------------------------------------------------------------------------------------
 Accessed at 2020-01-06T11:09:42+1300
====================================================================================




________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
                                                                                                                                                                  Strict Fields
````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
The lazy nature of Haskell can sometimes lead to some inefficiencies. One solution is data types with strict fields.

===================================================================================================================================================================================================================================================================
 A little diversion to learn to learn about     _|_     (bottom)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Suppose we have a unit data type     data Unit = Unit,     in a strict language (e.g., ML), it would have only one value     (Unit).     However, in Haskell, the unit data type has two values:     Unit,     _|_.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 _|_     can be thought of as a non-terminating or error-producing computation. E.g.,

 foo :: Unit
 foo = foo

 The above function     foo     produces an infinite loop, hence will produce the value     _|_.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 So, for a type     Maybe Unit,     there are four values:     _|_,     Nothing,     Just _|_,     Just Unit.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 To make the argument to     Just     be strict, i.e.,     Just _|_ == _|_,     we can use strict constructors as such:     data SMaybe a = SNothing | SJust !a.     The data type     SMaybe      has 3 values     (_|_, SNothing, SJust a)     instead of 4 now.
===================================================================================================================================================================================================================================================================



================================================================================================================================================================================================================================================================================================================================================
 Testing strict computations
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 After compiling     Strict.hs     using     ghc --make .\Strict.hs -o strict.exe     , running     strict.exe     with the options      a,     b,     c,     d,     e,     f,     g,     and     h     separately prints different errors for option     c     (printJust  (Just undefined))     and     g     (printSJust (SJust undefined)).
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Option     c     prints     Just     because the value is lazily evaluated, leading to     Just     being evaluated first and the value evaluated after it, which is     undefined,     leading to an error.
================================================================================================================================================================================================================================================================================================================================================
